\documentclass[a4paper,11pt]{article}

\frenchspacing
\usepackage[finnish]{babel}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{moreverb}

\setlength{\hoffset}{-1in}
\setlength{\voffset}{-1in}
\setlength{\topmargin}{1cm}
\setlength{\textheight}{25cm}
\setlength{\oddsidemargin}{25mm}
\setlength{\evensidemargin}{25mm}
\setlength{\textwidth}{16cm}

%\pagestyle{myheadings}
%\markright{Lols\hfill Foobaa\hfill}
\begin{document}

\thispagestyle{empty}

\vspace*{3cm}

\begin{center}

{ \Huge Aurinkokuntasimulaattori \\[1cm] }
{ \huge T-106.1243 Ohjelmoinnin jatkokurssi L1 \\
Projektin loppudokumentti \\ Aihe 129 \\[0.5cm] }
{ \Large Gravitoni -- GRaafinen Aurinkokunnan VIsualisaattori TOsi Nätisti Integroiden }

\end{center}

\vfill

\begin{flushright}

Konsta Hölttä\\
79149S\\
AUT 4. vk\\
konsta.holtta@aalto.fi\\
20.4.2011
\end{flushright}

\newcommand{\kuvaa}[4]{%
	\begin{figure}[h!]%
		\centering \includegraphics[width=#1\textwidth]{#2}%
		\caption{#3 \label{#4}}%
	\end{figure}%
}
\newcommand{\kuva}[2]{\kuvaa{0.6}{#1}{#2}{fig:#1}}

\newpage

\section{Yleiskuvaus}

% Yleinen kuvaus siitä, mitä on luotu. Tähän osioon voi monissa tapauksissa pitkälti lainata suunnitelmasta. Jos osioon on tullut olennaisia muutoksia suunnitelmaan nähden, niistä tulee mainita tässä. Jos aihe on mahdollista toteuttaa usealla eri vaikeusasteella, ilmaise myös, minkä tasoisena työ on lopulta mielestäsi toteutettu.

Ohjelma simuloi taivaankappaleiden ja rakettien liikkeitä. Ennalta aseteltujen kappaleiden ratoja lasketaan eteenpäin fysiikan lakien mukaisesti, ja radat voidaan tallentaa tiedostoon sekä laskentaa voi tarkastella reaaliajassa graafisella käyttöliittymällä kolmiulotteisessa maailmassa OpenGL:n avulla kuvakulmaa reaaliajassa säädellen. Jo simuloitua aikajanaa voi kelata taaksepäin sekä simulointia voi jatkaa koska tahansa loppupisteestä eteenpäin.

Simulaatio keskittyy gravitaatiovoimiin ja pienet häiriötekijät kuten ilmanvastus ja suhteellisuusteoria jätetään huomiotta. Algoritmi on kuitenkin matemaattisesti tarkka ja varsin todenmukainen, ja helposti laajennettavissa ulkoisten voimien lisäämiseksi. Integrointiin käytetään RK4:ää, mutta integrointimenetelmää on helppo vaihtaa koodista jos siihen tulee tarvetta.

Ohjelma toimii joko täysin itsenäisesti ilman käyttöliittymää vain lokiin tulostaen tai graafisen käyttöliittymän kautta ohjattuna. Kappaleiden ominaisuudet voidaan lukea asetustiedostosta sekä niitä voidaan lisätä käyttöliittymästä jälkeenpäin. Samaan asetustiedostoon sisällytetään myös säännöt ohjelman automaattiajoon, jolloin itsenäistä simulointia voidaan konfiguroida etukäteen painelematta nappuloita ohjelmasta. Ohjelma ohjeistetaan ajamaan joko tietty aikamäärä eteenpäin, tai kunnes kaksi kappaletta törmää toisiinsa. Mukana on myös raketteja, joita voi laukoa kiertoradoille tietyllä alkunopeudella. Tämä ominaisuus tekee ohjelmasta pelin, jossa pyritään esim. optimoimaan raketin moottorin käyttämä polttoaine, raketin kulkeman matkan pituus tms.

Olennaisia muutoksia suunnitelmaan nähden ei tullut. Työn toteutettiin vaikeustasolla haastava.


\section{Käyttöohje}

Ohjelman voi käynnistää ajamaan pelkkää simulaatiota komentorivillä tai lisäksi graafista käyttöliittymää. Komentorivimoodissa asetukset luetaan normaalisti, mutta maailma simuloidaan loppuun saakka eikä ohjelma ota muita syötteitä; gui-tilassa taas avataan ikkuna ja maailmaan voi vaikuttaa ja sitä voi tarkastella monin tavoin.

Tällä hetkellä kaikkein tärkein ohjelman toimintaan vaikuttava asia on sille annettava asetustiedosto, josta tietoa myöhemmin tiedostot-osiossa.

Koska ohjelma käyttää OpenGL:ää (JOGL), se pitää käynnistää (komentoriviltä ajettaessa) oikeilla ympäristömuuttujilla. Ohjelman mukana tulee hakemistot lib32 ja lib64, joissa on natiivit kirjastot 32- ja 64-bittisille linux-järjestelmille, sekä lib-hakemisto, jossa on jarit ajoa varten ja jogl-zippi eclipsen ohjeita varten. Mukana on myös apuskriptit run.sh, rungui32.sh ja rungui64.sh, jotka asettavat ympäristömuuttujat oikein ajoa varten; näille voi antaa suoraan asetustiedoston (ja simulointiajan) parametreiksi.


\subsection{Komentorivi}

Komentoriviltä ohjelmalle annetaan vain tiedostonimi ja simulaation loppuaika sekunteina. Simulaatiota tapahtuu joko tähän ajanhetkeen saakka tai kunnes asetuksissa määrätty loppuehto täyttyy (esim. törmäys). Esimeriksi seuraava simuloi vuoden verran eteenpäin:

\begin{verbatim}
java gravitoni.Gravitoni conf/all.conf 31536000
\end{verbatim}

Tai apuskripteillä:
\begin{verbatim}
./run.sh conf/all.conf 31536000
\end{verbatim}

Komentorivin ajosta kiinnostava tuloste on lokitiedosto(t), jotka määrätään asetuksissa. Ohjelma tulostaa hieman debugdataa käynnistyessään ja mm. törmäysten sattuessa.

\subsection{GUI}

Graafisessa näkymässä maailmaa voi tarkastella joustavammin ja siihen voi vaikuttaa kesken kaiken. Näkymässä on kaksi tilaa: testailunäkymä (kuva \ref{fig:testailutila}) ja numeerinen yksityiskohtainen näkymä (kuva \ref{fig:numerotila}). Testailunäkymässä avaruuden tila näkyy opengl-canvasissa ja joitain nippelitietoja kappaleista näkee vasemmalla infopaneelissa. Numeronäkymässä maailman tilaa voi katsella excel-tyyliin numeerisesti taulukossa.

GUI-tila käynnistetään muuten samoin kuin komentorivi, mutta askelmäärä jätetään antamatta. Asetustiedostokaan ei ole pakollinen; sen voi ladata valikoistakin.


\subsubsection{Katselutila}

Katselutilan pääpaino on 3d-näkymässä, jota voi raahailla hiirellä eestaas ja josta voi valita planeettoja. Se tottelee seuraavia käyttäjän komentoja:

\begin{itemize}
\item Hiiren rulla zoomaa koko näkymää
\item Hiiren rulla shift pohjassa zoomaa kappaleiden kokoja
\item Hiiren raahaus vasen näppäin pohjassa pyörittää näkymää
\item Hiiren raahaus keskinäppäin pohjassa siirtää näkymää
\item Välilyöntinappi, asettaa valitun kappaleen suhteelliseksi origoksi
\item Nappi >, valitsee seuraavan kappeleen
\item Nappi <, valitsee edellisen kappaleen
\item Nappi r, resetoi näkymän
\item Nappi p, togglaa pause
\item Nappi c, togglaa origokursorin näkymisen
\item Nappi e, togglaa auringon tason näkymisen (TODO ecliptic plane)
\end{itemize}

Infopaneelista voi seurata/säätää seuraavia asioita:

\begin{itemize}
\item Nykyisen planeetan sijainti ja nopeus
\item Kahden valitun planeetan välinen etäisyys
\item Simulaation nopeus ja aika (ylempi slider on nopeusprosentti, alempi aikaprosentti)
\end{itemize}

Jos simulaatio on pysäytettynä (pause-tilassa), sen nopeutta ei voi säätää, mutta ajanhetkeä kylläkin. Ajanhetki vaikuttaa siihen, mihin simuloinnin indeksiin asti ruutua piirretään. Jatkuvasti simuloivassa tilassa taasen nopeutta voi säätää, ja aika on koko ajan simuloinnin loppuhetkessä.


\subsubsection{Numerotila}

Numerotila on excelin tyyppinen näkymä, josta näkee nykyhetken tilan laajemmin koko konfiguraatiolle. Eri kappaleiden sijainnit, nopeudet yms. tiedot näkee samanaikaisesti yhdestä taulukosta sekä niitä voi muokata taulukon soluista suoraan.


\subsubsection{Valikko}

Valikosta voi avata tiedoston, sulkea ohjelman sekä lisätä ja poistaa planeettoja. Tiedoston avaaminen pysäyttää simulaation ja sulkee nykyisen maailmakonfiguraation ja avaa uuden kuin ohjelma olisi käynnistetty tällä uudella tiedostolla. Ohjelmasta poistuminen myös sulkee konfiguraation välittömästi. Planeettojen lisääminen ja poistaminen onnistuu vain numerotilassa turvallisuuden vuoksi, koska ohjelman kannattaa olla pausetilassa kappaletta muokatessa mihin se menee itsestään numerotilaan siirtyessä.


\section{Ohjelman rakenne}

\kuvaa{1}{graph.png}{Toteutunut luokkajako ja joitain tärkeimpiä metodeita. Kaavio ei ole UML:ää eikä mitään muutakaan standardia muotoa. Viivat kuvaavat jonkinlaista interaktiota luokkien välillä.}{rakennekuva}

Rakenne (kuvassa \ref{fig:rakennekuva} säilyi pääpiirteittäin samanlaisena kun mitä suunniteltiin; jotkut yksityiskohdat vähän elivät eri suuntiin. Koodin rakenne hajautuu neljään pääkategoriaan:

\begin{itemize}
	\item Konfiguraatiotiedostojen hallinta: geneerinen konffijärjestelmä, joka ei tiedä mihin sitä käytetään.
	\item Simulaatio integrointeineen: kappaleet jotka sisältävät mm. paikan, nopeuden ja massan; maailma, joka sisältää kappaleet, sekä oheisluokkia mm. integrointiin ja lokittamiseen.
	\item Käyttöliittymä ja dialogit: käli on pääasiassa yksi ikkuna, jossa on modulaarisesti eri asetuspaneeleita sekä 3d-canvas erillisinä luokkina.
	\item Graffarenderöinti ja sen käyttöliittymä: renderöijä kyselee kappaleiden tiedot maailmalta ja piirtää ne näytölle, sekä käsittelee mm. näppäimistösyötteet joilla näkymässä voi liikkua.
\end{itemize}

\subsection{Konfiguraatiot}

Tämä jäi ohjelman kokonaisuuden kannalta varsin pieneksi osaksi (kuten oli suunnitelmassakin), mutta ei sovellu sinänsä suoraan mihinkään kolmesta muusta kategoriasta, ja on siinä määrin geneerinen että tämän erikseen oleminen on vain kaunista. Seuraavassa esitellään itse luokkien toiminta; katso tiedostoformaatin tarkka muoto kohdasta Tiedostot.

Config-luokka vastaa yhtä asetusryhmää, jolla on jokin tyyppinimi ja joka on konffitiedostossa aaltosulkujen sisällä. Asetusryhmän sisällä voi olla asetuksia (nimi/arvo-pari; esim. kappaleen nimi tai sijainti) sekä muita asetusryhmiä. Tämä näkyy siten, että sillä on jäseninään yksi ConfigBlock sekä lista toisia Configeja (taulukkomapissa, koska ryhmiä haetaan nimen perusteella aina). Configin voi yhdistää toiseen merge-metodilla, jolloin yhdistettävän sisältämän ConfigBlockin ja Config-mapin asiat liittyvät yhdistäjään.

ConfigBlock on yksi asetusläjälohko, joka sisältää yleensä yhdelle asialle (esim. Body) kuuluvat ominaisuudet. Se sisältää ne nimi/arvo-parit, joita voi hakea mm. funktiolla get (palauttaa Stringin) tai getDouble (yrittää parsia arvon doubleksi ja palauttaa sen). Sen taianomainen apply-metodi toimii annotaatioilla ja sillä voidaan lukea lohkon arvot suoraan johonkin olioon, jonka jäsenmuuttjat on sidottu annotaatioiden avulla konfiguraatiomuuttujien nimiin.

\subsection{Simulaatio}

Grafiikka-agnostinen simulaatio-osio on projektin matemaattisin osa ja se osa missä itse simulogiikka tapahtuu lokittamisen kera. Komentorivitilassa softa käyttää ainoastaan konffitiedostoja ja simulaatiota.

Vektoriluokka Vec3 kuvaa kaikkia kolmiulotteisia matemaattisia vektoreita. Näitä ovat mm. kappaleiden sijainnit, nopeudet ja kiihtyvyydet. Vektoria hyväksikäytetään myös mm. grafiikkakoodissa rgb-värien varastointiin. Vec3 sisältää vektorien perusominaisuudet kuten toiseen vektoriin summaamisen sekä piste- ja ristitulon ja lisäksi yksinkertaisia apumetodeita kuten sijoittamisen toisesta vektorista tai olion kloonausmetodin.

Kappaleen perusluokka on Body joka varastoi yhden kappaleen kaikki tiedot. Bodyllä on myös aliluokka Kepler johon voidaan lukea asetuksista keplerkoordinaatit, jolloin sillä muunnetaan ne karteesiseen koordinaatistoon. Kappaleen päätarkoitus on erotella eri lentävien objektien ominaisuudet eri olioihin; kappaleella ei ihmeempää toiminnallisuutta ole.

Tavallisille planeetoille riittää Body-luokka. Rakettiluokka Rocket periytyy Bodystä, ja sillä on kiihtyvyysfunktiossa lisäksi johonkin aikaan loppuva vakiovoima joka kuvaa polttoainetta. Tätä voitaisiin jatkokehittää siten, että voimaa voisi ohjata tarkemmin käyttäjän syötteen perusteella.

Varsinainen maailmankaikkeuden toiminnallisuus on World-luokassa. Se varastoi listassa Body-oliot ja hoitaa interaktion simulaatiossa muiden luokkien välillä ja integroi pyydettäessä. Metodi loadConfig ottaa konfiguraatio-osion, josta haetaan Bodyjä vastaavat lohkot joilla instantioidaan Body-olioita. Metodi run ajaa integraattoria yhden parametrina tulevan aika-askeleen määrän verran. Integraattorin käyttämä metodi acceleration palauttaa tietyn hetken kiihtyvyyden annetulle planeetalle.

Worldilla on Integrator-rajapinnan toteuttava jäsenolio joka hoitelee itse algoritmin. Se kyselee Worldilta kiihtyvyyksiä tiettyinä ajanhetkinä eri kappaleille, ja siirtää kappaleita niiden mukaan. RK4 on oletuksena toimiva integraattori, mutta esimerkin vuoksi on tehty myös Verlet, sekä huonompi RK4 joka pitää muuta maailmaa paikallaan laskiessa yhdelle kappaleelle kiihtyvyyttä ajanhetkellä t+dt uudessa paikassa (luokka BadRK4). Integratorin selventämiseksi simussa on myös luokat State ja Derivative, jotka säilövät sijainteja ja kiihtyvyyksiä ilman erityisempää toiminnallisuutta.

World kans tsekkaa törmäilyt, XXX!

Integraatorit runkkaa koko maailmavektoria!

World osaa myös lokittaa ajon yhteydessä. Logger-luokka hoitaa kaiken lokittamisen kokonaisuudessaan, ja maailma kutsuu log()-metodia tarvittaessa. Loggerin sisällä on LogWriterista periytyviä olioita kuten GnuplotWriter ja CsvWriter. Nämä eri tyyppiset lokikirjoittimet kirjoittavat eri tyyppistä dataa tiedostoon nimensä mukaan.


\subsection{Käyttöliittymä}

Kuten käyttöohjeessa mainittiin, käyttöliittymä on kaksiosainen. Pääikkunaa kuvaa UI-luokka; se hoitaa ikkunan korkeimman tason asiat ja komentaa eri näkymiä, testailu- ja numerotilaa joista käyttöohjeessa mainittiin. Näiden kahden näkymän välillä siirrytään välilehtijutulla. Asetushässäkkä on taulukkoinputti joka hanskaa worldin bodyt.

3D-näkymän asiat hoidetaan grafiikan puolella GLCanvasia kuuntelevassa GLEventListeneristä periytyvässä Rendererissä, joka on UI:n sisällä myös. Tässä näkymässä on myös SettingPane, joka sisältää Widgettejä.

BodyWidget: kappaleen tiedot. Koostuu valikosta, josta valitaan käsiteltävä kappale, sekä muutamasta tekstilaatikosta joista näkee mm. kappaleen paikan. Käsiteltävän kappaleen voi klikata myös 3d-näkymästä, jolloin laatikon valittu elementti vaihtuu samalla.

DistanceWidget: etäisyyden laskenta. Valitaan kaksi kappaletta kuten BodyWidgetistä, ja näiden välinen etäisyys näkyy tekstilaatikossa. Kappaleet tähänkin voi valita 3d-näytöltä.

TimeWidget: simulaation ajan ja nopeuden säätö. Sisältää säätöpalkit ajanhetkelle ja simulaation piirtämisen nopeudelle.

SettingPane hoitaa widgettien puuhat eteenpäin tylsillä proxymetodeillaan. Käyttöliittymäjutut ovat tylsiä ja hoidetaan Swingillä ihan normaalisti.


\subsection{Grafiikat}

Grafiikkojen renderöinti keskittyy GLCanvas-luokasta periytyvään Renderer-luokkaan, joka hoitaa kappaleiden piirtelyn. Renderer sisältää GfxBody-olioita, joiden piirtometodeita kutsuu tarvittaessa (draw() tjsp). Renderer rekisteröi muutamia syötteenkäsittelijöitä UserInputHandler-luokkaan, joka hoitaa hiiren ja näppiksen interaktion. Näkymän katselusuunta muuttuu maailmaa pyörittäessä, zoomatessa ja siirtäessä. Nämä hoituvat erityisen kameramatriisin avulla, jota tuo handler pyytää päivittämään kun käyttäjä niin toivoo.

UserInputHandler toteuttaa erinäisiä tapahtumakuuntelijainterfaceja. Kun jotain näppäintä painetaan, se tekee jotain tarvittaessa. Hiiren napin mennessä pohjaan alkaa pyöritys- tai pannausoperaatio, ja kun hiirtä raahataan, handleri pyytää Rendereriä päivittämään näkymän kameraa muuttuneiden parametrien suhteen.

Koska maailman pyörittelyoperaatio vaatii hieman erikoista toimintalogiikkaa, se on ulkoistettu ArcBall-luokalle (joka on pienin muutoksin kopioitu raa'asti NeHe:n esimerkeistä (VAI ONKO?)). Kun pyöritys alkaa, ArcBallille kerrotaan hiiren alkusijainti. ArcBall projisoi tämän pisteen tietyn sikamageen pallon pinnalle ja ottaa pintapisteen muistiin. Kun hiirtä raahataan, pyörittely lasketaan kvaternioilla uuden hiiripisteen projisoituun paikkaan. Tästä lisää algoritmit-osiossa. Maailman pyörittelyn avuksi grafiikkapuolella on luokat Quat (kvaternio) ja Matrix4f (4x4 matriisi).

GfxBody on erillinen luokka, joka sisältää viittauksen Bodyyn jota se esittää. GfxBody ei periydy Bodystä, koska nämä ovat kuitenkin varsin eri asiat; piirrettävä objekti on tavallaan kääre Bodylle, eikä mikään Body erikoistoiminnoilla. Tämä myös selventää ohjelman toimintaa muualta, kun ei tarvitse tarkistaa, annetaanko simulaattorille listaa GfxBodyistä UI:n tapauksessa tai Bodyistä CLI:n tapauksessa. Periyttäminen ei itseasiassa olisi edes mahdollista, koska Bodyjen tilalla voi olla Rocketeja. GfxBody lukee asetuksista lisämääreitä kappaleelle: väri ja tekstuuri. Tekstuuria käytetään kappaleen piirtämiseen ja väriä liikehistoriakäppyrään; nämä selkeyttävät kappaleiden erottamista toisistaan. GfxBodyn päätehtävä on piirtää kappale liikehistorioineen, jonka se myös varastoi tiettyyn rajaan asti.

TextureReader on myös muualta lainattua koodia, ja sen tehtävä on eristää tekstuuritiedostojen lukeminen muualle.

% Ohjelman erottelu tärkeimpiin osakokonaisuuksiinsa, toteutuneen luokkajaon esittely. Minkälaisilla luokilla kuvaatte ohjelman ongelma-aluetta? Mitä ongelman osaa kukin luokka mallintaa? Mitkä ovat luokkien väliset suhteet? Entä millaisia luokkia käytätte ohjelman käyttöliittymän kuvaamiseen?

% Tässä kannattaa esittäkää myös mahdollisia muita ratkaisumalleja ja perustella valittu ratkaisu. Jos suinkin mahdollista, liittäkää mukaan jonkinlainen graafinen luokkakaavio (voitte käyttää esim. UML-luokkakaavionotaatiota, mutta se ei ole millään muotoa pakollista). Esitelkää luokkien keskeiset metodit. Huom. oleellista on vain se, mitä metodeilla tehdään, ei se, miten ne sisäisesti toimivat.

\section{Algoritmit}

\subsection{Simulaatio}

\subsubsection{Integrointi}

Pääalgoritmi on neljännen asteen Runge-Kutta-menetelmä (RK4). Kappaleiden tilat $y$ ja aika $t$ muuttuvat seuraavasti (alaindeksit y:lle ja t:lle kuvaavat integrointikierrosten indeksejä):

%\begin{equation}
\begin{align}
y_{n+1} &= y_n + \tfrac{1}{6} h \left(k_1 + 2k_2 + 2k_3 + k_4 \right) \\
t_{n+1} &= t_n + h
\end{align}
%\end{equation}

Arvot $k_i$ kertovat tietoja kulmakertoimesta ja määräytyvät seuraavasti:

%\begin{equation}
\begin{align} 
k_1 &= f(t_n, y_n)
\\
k_2 &= f(t_n + \tfrac{1}{2}h, y_n +  \tfrac{1}{2} h k_1)
\\
k_3 &= f(t_n + \tfrac{1}{2}h, y_n +  \tfrac{1}{2} h k_2)
\\
k_4 &= f(t_n + h, y_n + h k_3)
\end{align}
%\end{equation}

$k_1$ on kulmakerroin nykyhetkellä; $k_2$ on Eulerin menetelmällä laskettu puolikkaan aika-askeleen jälkeen; $k_3$ vastaava, mutta kulmakertoimen $k_2$ avulla; $k_4$ lopussa eli aika-askeleen päässä nykyhetkestä $k_3$:lla. Näiden painotettu keskiarvo määrää oletetun derivaatan kohdassa $n$.

Koska maailman tila on yhtenäinen eri kappaleiden suhteen ja kyseessä on periaatteessa yksi suuri tilavektori, ei kappaleiden tiloja päivitellä vaiheiden välillä erikseen, vaan kaikkien kappaleiden tilat lasketaan askeleiden välillä. Teknisesti tilavektori on hahmottamissyistä hajautettu erillisiin kappaleluokkiin. Esimerkiksi siis $k_2$:n laskemisessa yhtä kappaletta varten muuta maailmaa ei pidetä paikallaan, vaan vaikutus lasketaan kaikelle. Toisin sanoen muuttujat $y$ ovat vektoreita. Luokka BadRK4 on esimerkin vuoksi toteutettu väärällä tavalla, eli yhtä kappaletta siirrettäessä pidetään muuta maailmaa mikroaskelien kohdilla paikallaan. Luokka RK4 toimii oikein.

Vaihtelun vuoksi toteutettiin myös ns. Velocity Verlet.

\begin{align}
\vec{x}(t + \Delta t) &= \vec{x}(t) + \vec{v}(t)\, \Delta t + \frac{1}{2} \,\vec{a}(t) \Delta t^2
\\
\vec{v}(t + \Delta t) &= \vec{v}(t) + \frac{\vec{a}(t) + \vec{a}(t + \Delta t)}{2} \Delta t
\end{align}

Tämä on helppo muuttaa koodiksi siten, että uusi paikka lasketaan ensin, sitten uuden paikan kohdassa lasketaan kiihtyvyys uudessa kohdassa, ja lopuksi uuden nopeuden laskemiseen käytetään vanhaa ja uutta kiihtyvyyttä.


TODO: koodissa paskasti. ei vektoreina.

\subsubsection{Törmäysten hallinta}

Törmäykset hallitaan kahden kappaleen välisinä tarkistuksina: integroinnin jälkeen tarkistetaan, onko kahden kappaleen välinen etäisyys pienempi kuin niiden säteet yhteenlaskettuna. Mikäli näin on, tehdään jokin törmäyshallinta: ei tehdä mitään, pysäytetään simulaatio tai kimmotetaan kappaleet.

Jos ei tehdä mitään, simulaatio jatkuu ja kappaleet menevät toistensa lävitse. Pienellä aika-askeleella kappaleiden välinen voima lasketaan väärin (jos ne ovat sisäkkäin, gravitaation vaikutus on erilainen) ja kappaleet singahtavat kauas toisistaan. Teoriassa kappaleet voivat päätyä myös tasan päällekkäin, jolloin niiden välinen nollaetäisyys aiheuttaa nollallajakovirheen.

Kimpoaminen hallitaan täysin kimmoisasti massakeskipisteen kautta. Liikemäärävektorit muunnetaan massakeskipistekoordinaatistoon ja kaavat pyöritellään sitä kautta niin, että tässä koordinaatistossa kappaleet liikkuvat suoraan toisiaan kohti jolloin niiden nopeuksien merkki vaihtuu. Massakeskipiste:

\begin{align}
p_cm &= (m_1 + m_2) v_cm = p_1 + p_2 \\
v_cm &= \frac{m_1}{m_1 + m_2} v_1 + \frac{m_2}{m_1 + m_2} v_2
\end{align}

Uudessa koordinaatistossa:

\begin{align}
v_{1,cm} &= v_1 - v_{cm} \\
p_{1,cm} &= p_1 - m_1  v_{cm} = m_1 v_1 - (m_1 \frac{m_1}{m_1 + m_2} v_1 + m_1 \frac{m_2}{m_1 + m_2} v_2) \\
&= \frac{m_1 m_2}{m_1 + m_2} (v_1 - v_2)
\end{align}
Kappaleelle 2 vastaavasti.

Nyt liikemäärän muutos on molemmille kappaleille vain merkinvaihto, eli liikemäärän muutos on itse liikemäärä kaksinkertaisena ja negatiivisena. Tästä takaisin maailmakoordinaatistoon muuttamalla saadaan

\begin{align}
\delta v_1 = \delta p_1 / m_1 = -2 \frac{m_1 m_2}{m_1 + m_2} (v_1 - v_2)
\end{align}

ja sama kappaleelle 2 vastaavasti. Tämä nopeuden muutos vaihdetaan integroinnin jälkeen integraattoriluokassa, jos asetukset ovat niin määränneet.

\subsection{Muuta}

Asetustiedostot jaetaan tavallaan rekursiivisesti, mutta kuitenkin iteratiivisesti. Alkuperäinen jostain tekstivirrasta ladattava Config luo muita Config-olioita, jos niitä tulee tiedostossa vastaan. Näitä ei kuitenkaan ladata niiden Configien latausfunktioissa, vaan ylimmän tason Config instantioi kaikki. Koska Configeja voi näin olla sisäkkäin, pidetään eri asetusryhmien tasoista muistia pinossa (Deque). Nykytasolla käsiteltävä Config on erikseen muistissa, ja kun uuden asetusryhmän alku tulee vastaan, nykyryhmä laitetaan pinoon ja uudeksi nykyryhmäksi tulee tämä uusi. Kun ryhmä loppuu tietovirrassa, nykyryhmäksi popataan pinon päältä uusi. Tätä ei tehty rekursiivisesti, koska aluksi ConfigBlockit ladattiin vähän hassusti iteratiivisesti ja kiireessä oikea rekursio olisi vaatinut enemmän aikaa.

Grafiikan piirrossa suhteellinen origo on mainitsemisen arvoinen ominaisuus. Globaalin koordinaatiston origo on vaihdettavissa johonkin planeettaan, jolloin eri planeettojen sijainnit ja radat piirretään suhteessa siihen, missä tämä origokappale oli kuhunkin aikaan. Näin jos aurinko liikkuu globaalin koordinaatiston suhteen, voidaan se asettaa origoksi jolloin muiden planeettojen paikat ja radat nähdään selvemmin, kun kokonaisuus ei vaella pikkuhiljaa.

% Sanallinen kuvaus käyttämistänne algoritmeista, eli siitä miten ohjelma suorittaa tarvittavat tehtävät. Esim. miten tarvittava matemaattinen laskenta tapahtuu? (kaavat mukaan) Miten algoritminne löytää lyhimmän tiereitin kahden kaupungin välille? Miten toteuttamanne pelin tekoäly toimii? Kaavioita tms. voi käyttää apuna tarpeen mukaan. Mitä muita ratkaisuvaihtoehtoja olisi ollut? Perustelkaa valintanne: Verratkaa toteutusta johonkin toiseen ratkaisuun, ja selittäkää miksi päädyitte juuri tähän.

% Tässä kohdassa on siis tarkoitus selostaa ne periaatteet, joilla ongelmat on ratkaistu, ei sitä, miten algoritmit koodataan. Siis ei luokkien tai metodien kuvauksia tai muitakaan Javaan tai ohjelmakoodiin liittyviä seikkoja tänne. Pseudokoodiesitys keskeisimmistä ei-tunnetuista algoritmeista on kuitenkin hyvä olla sanallisen kuvauksen tukena. HUOM! Jokaisessa työssä on aina algoritmeja, toiset ehkä yksinkertaisempia kuin toiset, moni aivan itse alusta saakka keksittyjä. Kuvaa tässä niistä muutama kaikkein olennaisin.

\section{Tietorakenteet}

Kappaleita voi lisäillä kesken kaiken, joten niitä varastoidaan ArrayListeissä eikä ihan perustaulukoissa. Sama kappaleiden historiadatalle yms. Suora indeksointi on suhteellisen harvaa ja kappaleita lähinnä iteroidaan läpi, joten tilalle sopisi myös linkitetty lista. Sen hyvistä puolista ei tosin juuri ole hyötyä, koska keskeltä ei poisteta tai lisäillä olioita juuri koskaan.

TODO: Historiadata vois olla linklistissä.

Asetusryhmän (Config) sisältämät toiset ryhmät varastoidaan sekä taulukoita sisältävässä hashmapissa että kaikki kerrallaan yhdessä taulukossa. Hashmapista saa taulukollisen tietyn nimisiä ryhmiä, koska tätä tarvitaan jossain (esim. haetaan kaikki body-ryhmät). Näin ryhmiä ei tarvitse hakea kaikkien ryhmien sisältävästä taulukosta aina, kun niitä tietyllä nimellä tarvitaan.

Raakoja taulukoita käytetään integraattorissa, kun tarvitaan useita väliaikaistaulukoita joiden koko ei muutu miksikään, vaan ne alustetaan valmiiksi oikean kokoisiksi.

% Minkälaiset kokoelmatyypit/tietorakenteet soveltuvat parhaiten ohjelmassa tarvittavan tiedon varastoimiseen ja käsittelyyn? Miksi? Mitä muita valintamahdollisuuksia olisi ollut? Tarvitsitteko dynaamisia rakenteita (so. muuttuvan kokoisia, esim. listat (ArrayList)) vai riittivätkö esim. taulukot? Jos käytitte Javan valmiita tietorakenteita, ei niiden tarkkaa määrittelyä tarvitse esittää. Jos taas ohjelmoitte itse jonkin tietorakenteen, on sen toimintatapa selostettava.

\section{Tiedostot}

Tiedostoformaatti suunniteltiin helppoa muokattavuutta silmällä pitäen. Koska maailman tiedot kuitenkin kannattaa kirjoittaa ihmisen toimesta tiedostoon eikä naksutella GUIsta, muoto on varsin minimalistinen eikä kovin ihmeellinen.

Esimerkki 1, planeetan määritykset:
\begin{verbatimtab}[4]
/* C-tyylisiä kommentteja tuetaan */
/* Kommentit voivat
 * olla monirivisiäkin */ /* ja monta per rivi */
body {
        name Earth /* kappaleella on nimi */
        mass 5.9736e24 /* luvut ovat Double.parseDouble-muodossa */
        radius 6371e3
        kepler { /* kepler-koordinaatit */
                center Sun
                a 149598261e3
                e 0.01671123
                i 7.155
                w 114.20783
                ma 357.51716
                O 348.73936
        }
        gfx {
                texture earth.png
                color 0,0,1
        }
}
\end{verbatimtab}

Esimerkki 2, itse asetustiedosto joka annetaan ohjelmalle:
\begin{verbatimtab}[4]
include conf/constants.conf
dt 864 /* sadasosa päivästä */

log.defaults {
        type gnuplot
}
log {
        tick 1
        file full.log
}
log {
        tick 100 /* kerran päivässä */
        filter Sun /* lokita vain aurinko */
        file sun.log
}
log {
        tick 10
        filter Earth
        file earth.log
}
include conf/sun.conf
include conf/mercury.conf
include conf/venus.conf
include conf/earth.conf
include conf/moon.conf origin=body:Earth vorigin=body:Earth
\end{verbatimtab}

Include-sana lukee toisen tiedoston ja sisällyttää sen siihen kohtaan, missä se sijaitsi alkuperäisessä. Tämä hoidetaan Configin merge-metodilla. Includaamiselle voi antaa erityisparametreja, toistaiseksi origin ja vorigin, joilla säädetään sen alla olevia globaaleja muuttujia. Näin alitiedostolle saadaan suhteellinen alkuorigo, eikä esim. kuun sijaintia tarvitse laskea maan koordinaateista käsin. origin=body:Earth käy, sekä myös koordinaattipohjainen muoto origin=pos:10,20,30. Myös nopeusorigon voi asettaa; se on vorigin.

Asetusryhmällä on jokin nimi (esim. body, kepler tai log) ja se on aina jonkin toisen asetusryhmän sisällä, poislukien ylimmän tason ladattava tiedosto joka ei ole minkään sisällä. Ryhmän sisältö ympäröidään aaltosuluilla. Parserissa ei ole kovinkaan paljon älyä, joten avaavan aaltosulun on oltava rivin lopussa, ja sulkevan on oltava rivin ainoa merkki. Välilyöntejä, tabeja ja kommentteja ei tosin lasketa tähän.

Kappaleille voi antaa sijainti- ja nopeusvektorin, tai sitten kepler-lohkossa keplerblah orbital parameters -jutut, mistä ne päätellään. Kulmat ovat asteissa.


% Selostakaa tässä osiossa myös millaisia tiedostoja ohjelmasi käsittelee, jos mitään. Esim. ovatko ne tekstitiedostoja vai binaaritiedostoja, ja miten tieto on niissä esitetty? Kuvatkaa lopullinen tiedostoformaatti sillä tasolla, että assitentti voi halutessaan helposti luoda ohjelmalle testidataa. Laittakaa liitteeksi joitakin tiedostoja joita ohjelma tarvitsee/on tuottanut.
\begin{itemize}
\item Config: tarkistetaan, että latausmetodit lataavat globaalit muuttujat ja blokit kunnolla sekä skippaavat kommentit.
\item ConfigBlock: getterit palauttavat oikean arvon niitä hakiessa. Esim. getInt heittää poikkeuksen mikäli arvoa ei voi tulkita kokonaislukuna. Setterit vastaavasti.
\item Simulaation toimivuus: Pyöritellään maapalloa auringon ympärillä pari aika-askelta ja katsotaan, että on siellä minne ennustettiin. Kiihtyvyysfunktiosta katsotaan, että kaikki planeetat vaikuttavat toisiinsa.
\item Lagrangen pisteessä oleva kappale ei integroidessa liiku suhteessa muihin.
\item Törmäykset: törmäystarkistusmetodi reagoi oikein kun kappaleet ovat liian lähekkäin.
\item Käyttöliittymän napit tekevät mitä pitääkin; testattava lähinnä käsin.
\item Asetuswidgettien chooseBody-metodit ym. reagoivat esim. valitsemalla oikean kappaleen.
\item Renderer piirtää sille annetut palikat oikeisiin kohtiin. Apurakenteeksi jokin testihomma joka käynnistää rendausikkunan dummykappaleilla.
\item Rendererin navigointimetodit; testattava käsin.
\end{itemize}

\begin{itemize}
	\item Ladatun asetustiedoston tietojen oikeellisuus suhteessa tiedoston sisältöön (helppo testata koneellisesti).
	\item Virheellisen asetustiedoston oikeaoppinen hallinta: configluokka heittää poikkeusta ja pääohjelma käsittelee sen sopivasti ja ilmoittaa käyttäjälle ongelmasta.
	\item Simulaation kaavojen toimivuus: Lagrangen pisteessä oleva kappale pysyy paikallaan; maa kiertää auringon siinä ajassa kun oikeastikin eikä niiden välinen etäisyys muutu.
	\item Kappaleiden lisäys konfigurointikäyttöliittymässä: käyttöliittymä reagoi kuten haluttaisiin ja kappale ilmestyy listoihin ja 3d-näkymään.
	\item Kappaleiden muokkaus: simulaatio reagoi sitä mukaa kun kappaleelle säätää vaikka uuden paikan tai massan.
	\item Luonnonvakioiden ja muiden yleismuuttujien muokkaus: simulaatio reagoi vastaavasti.
	\item Renderöinnin oikeellisuus planeettojen sijaintien, suuntavektorien, ratojen ym. osalta: kappaleiden sijainnit vastaavat toisiaan konfiguraationäkymässä lokitiedostossa.
	\item 3d-näkymässä liikkuminen: näppis ja hiiri toimivat odotetusti.
	\item Kappaleen valinta 3d-näkymästä: näkymästä klikatessa oikea planeetta valitaan, konfigurointipaneeli reagoi valintaan ja 3d-näkymässä näkyy korostettuna, että kappale on valittu.
	\item Kappaleen siirto 3d-näkymässä: valittua kappaletta voi raahailla hiirellä.
	\item Kappaleen seuranta 3d-näkymässä: kappale pysyy näkymän keskipisteessä liikkuessaankin.
	\item Origon määritys: muu maailma käyttäytyy siten kun seurattu kappale olisi origo.
	\item Satelliitin laukaisu: 3d-näkymä ja simulaatio reagoivat oikein kun konfigurointipaneelista painetaan nappia satelliitin lähettämiseksi.
\end{itemize}


\section{Testaus}

Ohjelman päätoiminnallisuutta testattiin yksikkötesteillä sekä isompia ja grafiikkaan liittyviä testejä tehtiin käsin. Asetuksille on muutama yksikkötestaus, mutta niitäkin tuli kokeiltua käsin niin, että ne toimivat halutusti kokonaisuuden kera.

Simulaation oikeellisuus koestettiin pääosin testailunäkymästä katselemalla, että vuosia eteenpäin simuloimalla kappaleiden radat pysyvät oikeina sekä ajamalla yksinkertaisia automaattisia testejä ja seuraamalla ajolokeja. Lagrangen pisteiden haxailua ei testailtu (TODO: joopa!! tehää tehää)

Törmäykset testattiin tekemällä asetustiedosto jossa on kaksi kappaletta paikallaan, ja toteamalla että komentoriviohjelma päättyy kun ne törmäävät; törmäyksen saa tarkasteltua lokitiedostoista helposti jälkeenpäin.

Monia ohjelman toiminnallisuuksia tuli kokeiltua käyttöliittymästä, ja käyttöliittymän toimivuus tuli tarkistettua siinä samalla. Eri tiloista toisiin piti kokeilla että kaikki toimivat edelleen; esim. pausetilan syklittäminen ei hajota mitään. Kappaleiden muokkaus toimii testatusti ja planeetat siirtyvät kun niiden tietoja muokataan numeronäkymästä.

Renderöinti näyttää oikealta ja siinä navigointi (pyöritys ja siirto) toimii odotetusti.

Kaikki toteutetut asiat testattiin ja todettiin toimivaksi.

Esimerkiksi törmäystestaus hoituu helposti antamalla ohjelmalle conf/collisiontest.conf-tiedosto ja muokkaamalla siitä collisiontype-muuttujaa.

% Kertokaa miten ohjelmaa testattiin ja kuinka se vastasi suunnitelmassa esitettyä.

% Läpäiseekö ohjelma kaikki suunnitelmassa esitetyt testit? Kuinka ohjelmaa testattiin sitä rakennettaessa? Oliko testauksen suunnittelussa jotain olennaisia aukkoja?

\section{Ohjelman tunnetut puutteet ja viat}

Virhetilanteiden hallinta ei ole erityisen käyttäjäystävällistä. Jotkut paikat heittävät tarkoituksella RuntimeErroreita, koska käyttöliittymän virheilmoitusten hallinta ei erityisemmin kiinnostanut eikä sitä ollut määritelty suunnitelmassa erityisen tarkasti. Ohimennen suunniteltiin, että käyttöliittymä käsittelisi asetustiedostojen poikkeukset, mutta niitä ei priorisoitu korkealle ja jäivät toteuttamatta; oletetaan, että käyttäjä tarkastelee konsolia poikkeusten varalta. Toisaalta poikkeuksia ei tavallisessa käytössä pitäisi ihmeemmin lennellä, vaan enimmäkseen asetustiedostojen virheellisyydestä. Poikkeusten kuvausviestit ovat kuitenkin järkeviä, kuten esim. jos asetustiedostosta noustaan ylimmänkin tason yläpuolelle (eli siellä on ylimääräinen \}-merkki), lentää virhe viestillä ''One does not simply ascend out from the topmost config section!''.

Jotkut suunnitellut ominaisuudet jäivät toteuttamatta; näistä puutteista tarkemmin kohdassa Poikkeamat suunnitelmasta.
%Kuvaa tässä osiossa kaikki tuntemasi puutteet ja viat ohjelmassasi. Kerro miten korjaisit nämä ongelmat jos jatkaisit projektia. Mitä vähemmän assistentti löytää puutteita kohdista joiden väität toimivan sen parempi. Ole siis rehellinen. 

Nimissä ei saisi olla duplikaatteja, mutta sitä ei testata.

\section{3 parasta ja 3 heikointa kohtaa}

Teknisesti parhaita lienevät asetustiedoston nätti rekursiivisuus ja lokitiedostojen modulaarisuus, keino-origon säätö ja yleinen koodin laajennettavuus mihin kuuluu lokitiedostojen säädettävyys ja integrointimenetelmän joustavuus. Toki RK4-integrointikin on mukavan tarkka, mutta sehän on prujattu wikipediasta eikä itse menetelmä ole omaa tuotantoa.

Heikoimpia kohtia ovat käyttöliittymän rumuus ja kankeus, virhetilanteiden viimeistelemättömyys käyttäjän näkökulmasta sekä automaattisten testien vähyys.


% Assistentti käyttää runsaasti aikaa tutustuessaan ohjelmaasi, mutta ei välttämättä näe toteutustasi samalla tavoin kuin sinä. Jos ohjelmassa on joitakin kohtia joita itse pidät erityisen hyvinä, mainitse tässä niistä 1-3 kappaletta lyhyen perustelun kera. Jos ohjelmassa on kohtia jotka itsekin tiedät heikoiksi, voi mainita myös nämä. Tällöin mahdollisuus että nämä heikot kohdat dominoivat arvostelua vähenee huomattavasti. Tässä voi myös esittää sanallisesti kuinka olisi nämä asiat halutessaan korjannut. 

\section{Poikkeamat suunnitelmasta}

Joitain suunniteltuja ominaisuuksia puuttuu, koska projektiin ei käytetty ihan niin paljoa aikaa kuin mitä alussa tuli kuviteltua.

Suunniteltu anaglyfikolmiulotteisuus jäi toteuttamatta, mutta se on helppo lisätä, sillä opengl tukee sitä varsin suoraan. Se onnistuisi renderöimällä kahdesti päällekkäin vaihtamalla kameran sijaintia ja värimaskia välissä.

Kappaleita ei voi siirtää tai seurata 3d-näkymässä. Siirtäminen olisi kuitenkin hankalaa tehdä tarkasti, jolloin on parempi muokata suoraan numeroarvoja. Seuranta vain ei ehtinyt mukaan.

Satelliitin/raketin laukaisulle ei ole käyttöliittymässä nappia eikä niitä voi lisätä jälkeenpäin, vaan ne on laitettava asetustiedostoon valmiiksi (mallia voi ottaa conf-hakemiston esimerkkitiedostoista).

Törmäyksissä kappaleet eivät hajoa palasiksi. TODO.

% Teittekö jotain toisin kuin olitte suunnitellut? Miksi? Osuiko suunnitelmaan laatimasi ajankäyttöarvio oikeaan? Miksei? Entä toteutusjärjestys?

\section{Toteutunut työjärjestys ja aikataulu}

Projektin työjärjestys toteutui varsin oikein, sillä suunnitelmassa ollutta tuli seurattua miettiessä mitä koodaisi seuraavaksi, koska se oli rakenteellisesti hyvä. Aikataulu sen sijaan ei oikein toteutunut, koska lukukauden keskivaiheilla tuli niin merkittävästi muuta kiireellisempää puuhaa, että tämä jäi vähemmälle. Ajankäyttökin meni hieman pieleen, koska asioissa ei tullut keulittua lainkaan niin paljoa kuin mitä suunnitelmassa arvioitiin. Alussa tuli koodattua aika paljon, sitten hyvin vähän ja lopuksi deadlinen lähestyessä tuli loppuspurtti.

Seuraavassa viikkokohtaiset suunnitellut ja toteutuneet asiat:

\begin{description}
\item[7] Suunniteltu tutustumista ja vaihtoehtojen arviointia yms. Toteutui varsin tarkasti.
\item[8] Suunniteltu edelleen hahmottelua ja perustoiminnallisuuksia vähän kaikesta. Toteutui hieman jäljessä.
\item[9] Suunniteltu pientä kehittymistä edellisestä. Tässä otettiin edellistä hieman kiinni; toteutui.
\item[10] Suunniteltu käytettävyysjuttuja guin ja 3d-näkymän suhteen. Toteutuivat puoliksi tällä ja puoliksi edeltävällä viikolla.
\item[11] Suunniteltu 3d-näkymään tekstuurit ja navigointi sekä valinta. Ei toteutunut; kotimaan Rankka rokotti kouluhommista.
\item[12] Suunniteltu lokitiedostot ja numerotilan aloittelu. Toteutui hieman, tuli aloiteltua vähän kaikkea.
\item[13] Suunniteltu konffien virheellisyyden hallintaa ja konffauspaneelin reagointia muutoksiin. Tuli jatkettua viime viikon asioita ja aloiteltua näitä; toteutui kohtalaisesti.
\item[14] Suunniteltu 3d-näkymään hienouksia. Toteutui varsin hyvin edellisiin verrattuna.
\item[15] Suunniteltu viilausta; toteutui suunnitelmien puitteissa aika raskaasti.
\item[16] Suunniteltu DL:ään viimeiset viilailut, toteutui aggressiivisena koodaamisena ja dokumentaation pohdinnalla.
\end{description}

% Kerro tässä yleisellä tasolla missä järjestyksessä projekti lopulta toteutettiin (mielellään myös päivämäärät). Missä poikettiin suunnitelmasta? 
\section{Arvio lopputuloksesta}

% TODO: kiihtyvyysvektorit, suunta- ja nuo silleen et ne näkee, tekstit openglkanvasiin, törmäyshallinta, raketti

Projekti onnistui periaatteessa hyvin vaikka joitain hienouksia jäi toteuttamatta; oleelliset asiat löytyvät ja koodi on helposti laajennettavaa, jolloin kiinnostuksen jatkuessa hienoudet voi toteuttaa helposti vaikka pitkän ajan päästä. Koska perustoiminnallisuuteen ja hyvään koodiin sekä dokumentaatioon tuli kiinnitettyä eniten huomiota, huonona puolena käyttöliittymämukavuus ja viimeiset viilailut jäivät vähän vähemmälle.

Modulaarisuutta ja laajennettavuutta helpottavat mm. seuraavat ominaisuudet: Lisäasetuksia on helppo lisätä tarvittaessa, koska asetustiedostot ovat varsin käyttöagnostisia ja aidosti rekursiivisia. Lokitiedostotyyppejä voi kirjoittaa lisää lisäämällä Writer-luokkia. Integraattoria voi vaihtaa koodaamalla uuden luokan sitä varten ja vaihtamalla sen World-luokkaan käyttöön. Bodystä voi periä uudenlaisia lentokappaleita helposti. GfxBodyn voi erikoistaa piirtämään joitain muita kappaleita kuin palloja. SettingPaneen voi lisätä uusia ominaisuuksia naputtelemalla Widget-luokkia ja lisäilemällä niille sinne tuen.

Mielenkiintoista olisi ollut saada jostain suuri läjä eri kappaleiden tietoja (luokkaa satoja tai tuhansia kappaleita) ja testata ohjelman suorituskykyä ja todenmukaisuutta niillä.

% "Yhteenveto" ja itsearviointi joka voi toistaa yllämainittujakin asioita.

% Arvioikaa ohjelman laatua, kertokaa sen hyvistä ja huonoista puolista. Onko työssä oleellisia puutteita ja mistä ne johtuvat (mahdollinen hyvä perustelu dokumentissa voi korvata pienet puutteet)? Miten ohjelmaa olisi voinut tai voisi tulevaisuudessa parantaa? Olisiko ratkaisumenetelmien, tietorakenteiden tai luokkajaon valinnan voinut tehdä paremmin? Soveltuuko ohjelman rakenne muutosten tai laajennusten tekemiseen? Miksi tai miksi ei?

\section{Viitteet}

Simulaatiosta tuli lueskeltua muutama RK4-artikkeli. Keplerkoordinaattien muunnoksesta tuli luettua nippelitietoa sieltä sun täältä. Taivaankappaleiden keplerratatiedot ovat Wikipediasta kunkin kappaleen omalta sivulta, joita on turha erikseen luetella kaikkia. Javan API tarjosi ohjeita Swingissä. Swingin tutoriaalit olivat myös hyödyksi. OpenGL:n saloja tuli heräteltyä muistista muutamalla pienellä oppaalla sekä api-speksillä. Myös toteuttamattomia ominaisuuksia tuli opiskeltua, kuten anaglyyfipiirtoa ja barnes-hut-optimointia.

\begin{itemize}
\item \url{http://en.wikipedia.org/wiki/Verlet_integration}
\item \url{http://en.wikipedia.org/wiki/Runge-Kutta_methods}

\item \url{http://microsat.sm.bmstu.ru/e-library/Ballistics/kepler.pdf}
\item \url{http://ccar.colorado.edu/ASEN5070/handouts/kep2cart_2002.doc}
\item \url{http://www.colorado.edu/ASEN/asen3200/download.html}
\item \url{http://en.wikipedia.org/wiki/Kepler's_laws_of_planetary_motion}
\item \url{http://en.wikipedia.org/wiki/Standard_gravitational_parameter}
% \item \url{

\item \url{http://en.wikipedia.org/wiki/Solar_System}
\item \url{http://en.wikipedia.org/wiki/Orbital_elements}
\item \url{http://en.wikipedia.org/wiki/Earth} ym. planeetat

\item \url{http://download.oracle.com/javase/6/docs/api/}
\item \url{http://download.oracle.com/javase/tutorial/uiswing/components/index.html}

\item \url{http://nehe.gamedev.net/}
\item \url{http://timelessname.com/jogl/lesson01/}
\item \url{http://people.eecs.ku.edu/~miller/Courses/JOGL/jogl-1.1.1-docs/}

\item \url{http://paulbourke.net/texture_colour/anaglyph/}
\item \url{http://paulbourke.net/miscellaneous/stereographics/stereorender/}
\item \url{http://www.cs.princeton.edu/courses/archive/fall03/cs126/assignments/barnes-hut.html}

\item \url{http://cnx.org/content/m26666/latest/}
\item \url{http://en.wikipedia.org/wiki/Two-body_problem}
\end{itemize}

\section{Liitteet}

Lopuksi pari hassua esimerkkiä piirtelystä.

%Kaikkein tärkein projektin liite on projektin koko Java-lähdekoodi.

%Liitteeksi tulee lisäksi ainakin tekstipohjaisissa ohjelmissa laittaa muutama havainnollinen ajoesimerkki, jotka on kätevä tehdä Script-ohjelmalla. Graafisissa töissä ajoesimerkkejä ei vaadita, mutta muutama todellinen kuva ohjelman käytöstä joko erillisenä liitteenä tai käyttöohjeen yhteydessä ei tekisi pahaa. (Kuvia voi UNIX-ympäristössä napsia helposti XV-ohjelmalla (käynnistetään komennolla xv) tai Windows-ympäristössä painamalla Print Screen-nappulaa, mikä kopioi sillä hetkellä näkyvissä olevan näyttökuvan leikepöydälle, josta sen voi liimata vaikkapa Paint-ohjelmaan.)

%Jos olette tehneet ohjelmakoodista Javadoc-dokumentaatiota, niin linkittäkää myös se dokumentin yhteyteen.



\end{document}
